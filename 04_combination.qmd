---
output: html_document
editor_options: 
  chunk_output_type: console
---

## Consolidation des noms 

Charge toutes les données

```{r}
library(tidyverse)
library(sf)
library(arrow)
library(geoarrow)
library(stringdist)
library(wdpar)

# 1) CHARGER LES DONNÉES -----------------------------------------------

# Lecture de tes .rds en utilisant readr::read_rds (plutôt que readRDS)
angap_2002 <- read_rds("data/no_id/angap_2002.rds")
sapm_2010  <- read_rds("data/no_id/sapm_2010.rds")
sapm_2017  <- read_rds("data/no_id/sapm_2017.rds")
sapm_2024  <- read_rds("data/no_id/sapm_2024.rds") 
sapm_evol_2001_2011 <- read_rds("data/no_id/sapm_evol_2001_2011.rds")
vahatra <- read_rds("data/no_id/vahatra.rds")
wdpa_mdg_2025 <- wdpa_read("sources/WDPA_WDOECM_mar2025_Public_MDG.zip") %>%
  wdpa_clean(erase_overlaps = FALSE)

# Lecture du Parquet WDPA
# on convertit geometry en sf si on veut le manipuler de façon spatiale
wdpa_mdg_all <- read_parquet("data/MDG_WDPA_Consolidated.parquet")  %>%
  mutate(geometry = st_as_sfc(geometry)) %>%
  st_as_sf() 
```


On agrège tous les jeux de données. Ils n'ont pas tous les mêmes attributs, alors outre le nom et la géométrie, tous les attributs sont imbiqués dans une colonne spécifique.



```{r}
# Function to convert an sf/data.frame row into: 
#  - original_name, dataset, local_id as separate cols
#  - geometry as a separate col
#  - everything else inside 'attributes' as a single-row tibble
create_nested_structure <- function(df, name_col, dataset_id) {
  
  # Retain the original CRS and process the dataset
  df %>%
    # Convert sf -> tibble, keep geometry as is
    as_tibble() %>%
    # Add standard columns
    mutate(
      original_name = .data[[name_col]],
      dataset       = dataset_id,
      local_id      = row_number()
    ) %>%
    # Switch to rowwise so each row is processed individually
    rowwise() %>%
    # Create a list-col "attributes" that is a 1-row tibble 
    # with all columns except geometry/original_name/dataset/local_id
    mutate(
      attributes = list(
        as_tibble(
          pick(-geometry, -original_name, -dataset, -local_id)
        )
      )
    ) %>%
    ungroup() %>%
    # Keep exactly these five columns
    select(original_name, dataset, local_id, attributes, geometry) %>%
    # Reassign CRS explicitly to ensure consistency
    st_as_sf(crs = st_crs(df))
}


# create each "conso" dataset
angap_conso <- create_nested_structure(
  df         = angap_2002,
  name_col   = "NOM",
  dataset_id = "ANGAP_2002"
)

sapm2010_conso <- create_nested_structure(
  df         = sapm_2010,
  name_col   = "NOM",
  dataset_id = "SAPM_2010"
)

sapm2017_conso <- create_nested_structure(
  df         = sapm_2017,
  name_col   = "SHORT_NAME",
  dataset_id = "SAPM_2017"
)

sapm2024_conso <- create_nested_structure(
  df         = sapm_2024,
  name_col   = "SHORT_NAME",
  dataset_id = "SAPM_2024"
)

sapm_evol_conso <- create_nested_structure(
  df         = sapm_evol_2001_2011,
  name_col   = "NOM",
  dataset_id = "SAPM_evol_2001_2011"
)

vahatra_conso <- create_nested_structure(
  df         = vahatra,
  name_col   = "nom",
  dataset_id = "Vahatra_2017"
)

wdpa_conso <- create_nested_structure(
  df         = wdpa_mdg_all,
  name_col   = "NAME",
  dataset_id = "WDPA_2010_2024"
)


# Combine them
all_PAs <- bind_rows(
  angap_conso,
  sapm2010_conso,
  sapm2017_conso,
  sapm2024_conso,
  sapm_evol_conso,
  vahatra_conso,
  wdpa_conso
)
```


```{r}
# Match protected areas from x to y based on centroid distance and spatial overlap.
# Returns the original x with best matches from y, using overlap thresholds and ranking.
# Adds matched name, ID, and overlap percentage to x.
pa_match <- function(x, y,
                     pa_name_x = "original_name",
                     pa_name_y = "NAME",
                     pa_id_y = "WDPAID",
                     threshold_strong_match = 0.35,
                     threshold_weak_match = 0.1) {
  
  # Harmonize CRS and fix geometry
  y <- st_transform(y, st_crs(x)) %>%
    st_make_valid()
  
  # Prepare x and y with centroids
  x_aug <- x %>%
    mutate(index_x = row_number(),
           name_x = .data[[pa_name_x]],
           centroid_x = st_centroid(geometry))
  
  y_aug <- y %>%
    mutate(index_y = row_number(),
           name_y = .data[[pa_name_y]],
           id_y = .data[[pa_id_y]],
           centroid_y = st_centroid(geometry))
  
  # Find 3 closest y for each x
  x_matches <- x_aug %>%
    rowwise() %>%
    mutate(
      closest_y = list(
        y_aug %>%
          st_drop_geometry() %>%
          mutate(dist = as.numeric(st_distance(centroid_x, centroid_y))) %>%
          arrange(dist) %>%
          slice_head(n = 2) %>%
          select(index_y, dist)
      )
    ) %>%
    unnest(closest_y)

  # Compute spatial overlaps
  matches_with_overlap <- x_matches %>%
    rowwise() %>%
    mutate(
      overlap = tryCatch({
        inter <- st_intersection(geometry, y_aug$geometry[index_y])
        if (length(inter) > 0) {
          round(as.numeric(st_area(inter) / st_area(geometry)), 3)
        } else {
          0
        }
      }, error = function(e) 0)
    ) %>%
    ungroup() %>%
    mutate(
      name_y = y_aug[[pa_name_y]][index_y],
      id_y = y_aug[[pa_id_y]][index_y]
    ) %>%
  st_drop_geometry()

  # Rank and apply selection logic
  best_matches <- matches_with_overlap %>%
    group_by(index_x) %>%
    arrange(desc(overlap), dist) %>%
    mutate(rank = row_number()) %>%
    slice(1:2) %>%
    summarise(
      index_x = first(index_x),
      name_y = case_when(
        n() >= 2 && overlap[2] > threshold_strong_match && overlap[2] > overlap[1] ~ name_y[2],
        overlap[1] < threshold_weak_match ~ NA_character_,
        TRUE ~ name_y[1]
      ),
      id_y = case_when(
        n() >= 2 && overlap[2] > threshold_strong_match && overlap[2] > overlap[1] ~ id_y[2],
        overlap[1] < threshold_weak_match ~ NA_integer_,
        TRUE ~ id_y[1]
      ),
      overlap_y = case_when(
        n() >= 2 && overlap[2] > threshold_strong_match && overlap[2] > overlap[1] ~ overlap[2],
        overlap[1] < threshold_weak_match ~ NA_real_,
        TRUE ~ overlap[1]
      ),
      .groups = "drop"
    )

  # Join results back to x
  output <- x_aug %>%
    left_join(best_matches, by = "index_x") %>%
    select(-index_x, -name_x, -centroid_x)

  return(output)
}


all_PAs_matched <- pa_match(all_PAs, wdpa_mdg_2025)

all_PAs_unmatched <- all_PAs_matched %>%
  filter(is.na(name_y))

words_to_exlcude <- c("tsingy de",
                      "corridor entre parcelles i et ii d'",
                      "corridor", 
                      "extension",
                      "for[eê]t d['’]?", "aire protégée( d['’]?)?",
                      "androka",
                      "Maromena"
                      )

# Enhanced fallback matching function for protected areas
pa_match_fallback_name <- function(x, y,
                                   pa_name_x = "original_name",
                                   pa_name_y = "NAME",
                                   pa_id_y = "WDPAID",
                                   remove_terms,
                                   min_stringdist = 0.08) {

  # Clean and normalize names
  clean_name <- function(s) {
    pattern <- str_c(remove_terms, collapse = "|")
    s %>%
      str_to_lower() %>%
      str_replace_all(pattern, "") %>%
      str_squish()
  }

  # Create index for reinsertion
  x <- x %>% mutate(row_index = row_number())

  # Extract unmatched rows
  x_unmatched <- x %>%
    filter(is.na(name_y)) %>%
    mutate(name_x_raw = .data[[pa_name_x]],
           name_x_clean = clean_name(name_x_raw)) %>%
    distinct(name_x_clean, .keep_all = TRUE) %>%
    mutate(index_x = row_number())

  # Prepare y
  y_tbl <- y %>%
    st_drop_geometry() %>%
    mutate(name_y_raw = .data[[pa_name_y]],
           name_y_clean = clean_name(name_y_raw),
           id_y = .data[[pa_id_y]],
           index_y = row_number())

  # String distance matrix
  distance_matrix <- stringdistmatrix(x_unmatched$name_x_clean,
                                      y_tbl$name_y_clean,
                                      method = "jw", p = 0.1)

  # Get best match per unmatched row
  closest_matches <- tibble(
    index_x = rep(x_unmatched$index_x, times = nrow(y_tbl)),
    index_y = rep(y_tbl$index_y, each = nrow(x_unmatched)),
    dist = as.vector(distance_matrix)
  ) %>%
    group_by(index_x) %>%
    slice_min(dist, n = 1, with_ties = FALSE) %>%
    ungroup()

  # Join metadata
  matched <- closest_matches %>%
    left_join(x_unmatched, by = "index_x") %>%
    left_join(y_tbl, by = "index_y") %>%
    filter(dist < min_stringdist)

  # Compute overlap with matched geometry
  matched <- matched %>%
    rowwise() %>%
    mutate(overlap_y = tryCatch({
      inter <- st_intersection(geometry, y$geometry[index_y])
      if (length(inter) > 0) round(as.numeric(st_area(inter) / st_area(geometry)), 3) else 0
    }, error = function(e) NA_real_)) %>%
    ungroup()

  # Replace original rows
  x_updated <- x %>%
    left_join(
      matched %>%
        select(row_index, name_y = name_y_raw, id_y   = id_y.y, overlap_y, 
               stringdist = dist),
      by = "row_index"
    ) %>%
    mutate(
      name_y = coalesce(name_y.y, name_y.x),
      id_y = coalesce(id_y.y, id_y.x),
      overlap_y = coalesce(overlap_y.y, overlap_y.x),
      stringdist = if ("stringdist.x" %in% names(.)) coalesce(stringdist, stringdist.x) else stringdist
    ) %>%
    select(-row_index, -ends_with(".x"), -ends_with(".y"), -stringdist)

  return(x_updated)
} 

all_PAs_matched <- pa_match_fallback_name(x  = all_PAs_matched, 
                                          y = wdpa_mdg_2025,
                                          remove_terms = words_to_exlcude)

```

