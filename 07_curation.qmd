---
title: "Untitled"
format: html
---

# Curation

## Construction de la Spatial Amendment Table (SAT)

On documente ici la construction de la SAT, c’est à dire l’identification et la formalisation des géométries qui constituent des amendements spatiaux explicites par rapport à l’état courant décrit dans la WDPA.

La SAT ne vise pas à reconstituer exhaustivement l’historique spatial de toutes les aires protégées, mais à documenter de manière traçable et reproductible les cas où l’information spatiale disponible diverge de la WDPA, sur la base de sources légales, institutionnelles ou techniques identifiées.

Le principe général est le suivant: La WDPA est considérée comme l’état courant par défaut. Un amendement spatial est introduit uniquement lorsqu’une source indépendante, datée et justifiée indique une modification pertinente du périmètre ou de l’organisation spatiale d’une aire protégée.

### Identification des décisions légales impliquant une modification spatiale potentielle

La première porte d’entrée pour identifier des amendements spatiaux est constituée par les textes légaux recensés dans CNLEGIS. Certains types de décisions, en particulier celles qualifiées de modifiant, peuvent signaler une modification des limites ou du statut spatial d’une aire protégée.

Dans cette section, nous identifions les décisions légales qui mentionnent explicitement une modification, et les aires protégées concernées.

```{r}
library(tidyverse)
library(sf)
library(lubridate)
library(stringr)
library(tmap)
library(arrow)
library(geoarrow)
# Load legal decisions (FAT source)
pa_decisions <- read_rds("data/id/legal_texts.rds") |>
  mutate(
    cnlegis_url = ifelse(
      is.na(num_texte) | num_texte == "",
      NA_character_,
      paste0(
        "https://cnlegis.gov.mg/page_num_find_direct/?",
        utils::URLencode(num_texte, reserved = TRUE)
      )
    )
  )

# Filter decisions indicating a modification
modification_decisions <- pa_decisions |>
  filter(str_detect(type_decision, "modifiant"))

# List concerned protected areas
modification_decision_names <- modification_decisions |>
  distinct(WDPA_NAME) |>
  arrange(WDPA_NAME) |>
  pull(WDPA_NAME)

modification_decision_names
```

Nous identifions ainsi `r length(modification_decision_names)`  aires protégées pour lesquelles au moins une décision légale mentionne explicitement une modification.

Pour chaque décision légale identifiée comme potentiellement modificative, nous adoptons la logique suivante. Nous utilisons l'application interactive (Shiny) disponible dans le chapitre @sec-visual-verif. Nous observons la date et le contenu des décisions qui la concernent. Si les textes légaux indiquent bien une modification de périmètre, on passe en revue les données disponibles, afin d'identifier la source la plus crédible qui représente le périmètre précédent.

```{r}
tmap_mode("plot")
all_PAs_conso <- read_rds("data/id/all_PAs_conso.rds")

resolve_wdpaid <- function(wdpa_name_or_id, decisions) {
  # English: accept WDPAID (numeric) or WDPA_NAME (character) and return a single WDPAID
  if (is.numeric(wdpa_name_or_id)) {
    return(wdpa_name_or_id[1])
  }
  wdpaid <- decisions %>%
    filter(WDPA_NAME == wdpa_name_or_id) %>%
    pull(WDPAID) %>%
    first()
  if (is.na(wdpaid)) {
    stop("WDPAID introuvable pour: ", wdpa_name_or_id)
  }
  wdpaid
}

show_cnlegis_for_pa <- function(wdpa_name_or_id, decisions, pattern = NULL) {
  # English: show all CNLEGIS decisions for a PA, optionally filter by a pattern on type_decision
  wdpaid <- resolve_wdpaid(wdpa_name_or_id, decisions)

  out <- decisions %>%
    filter(WDPAID == wdpaid) %>%
    select(
      WDPA_NAME,
      WDPAID,
      date_texte,
      type_texte,
      num_texte,
      type_decision,
      id_texte,
      objet_texte,
      cnlegis_url
    ) %>%
    arrange(date_texte)

  if (!is.null(pattern)) {
    out <- out %>% filter(str_detect(type_decision, pattern))
  }

  out
}

plot_pa_sources <- function(
  wdpa_name,
  data = all_PAs_conso,
  decisions = pa_decisions,
  wdpa_historical_path = "data/MDG_WDPA_Consolidated.parquet",
  sources = NULL
) {
  # Check if input is a WDPAID (integer) or name (string)
  if (is.numeric(wdpa_name)) {
    wdpaid <- wdpa_name
  } else {
    # Look up the WDPAID from pa_decisions
    wdpaid <- decisions %>%
      filter(WDPA_NAME == wdpa_name) %>%
      pull(WDPAID) %>%
      first()

    # Check if WDPAID was found
    if (is.na(wdpaid)) {
      message("No WDPAID found in pa_decisions for: ", wdpa_name)
      return(NULL)
    }
  }

  # Filter all observations matching this WDPAID from all_PAs_conso
  pa_subset <- data %>%
    filter(WDPAID == wdpaid)

  # Load and filter WDPA historical data
  wdpa_historical <- read_parquet(wdpa_historical_path) %>%
    mutate(geometry = st_as_sfc(geometry)) %>%
    st_as_sf() %>%
    filter(WDPAID == wdpaid) %>%
    mutate(dataset_id = paste0("WDPA_", data_year)) %>%
    st_transform(st_crs(pa_subset))

  # Combine both datasets
  pa_subset <- bind_rows(pa_subset, wdpa_historical)

  # Filter by specified sources if provided
  if (!is.null(sources) && length(sources) > 0) {
    pa_subset <- pa_subset %>%
      filter(dataset_id %in% sources) %>%
      # Convert to factor with levels in the order specified by sources
      mutate(dataset_id = factor(dataset_id, levels = sources))
  }

  # Check if any results found
  if (nrow(pa_subset) == 0) {
    message("No protected area found with WDPAID: ", wdpaid)
    return(NULL)
  }

  # Get summary information
  n_obs <- nrow(pa_subset)
  datasets <- unique(pa_subset$dataset_id)

  # Print summary
  cat("\n=== ", wdpa_name, " ===\n")
  cat("WDPAID:", wdpaid, "\n")
  cat("Number of representations:", n_obs, "\n")
  cat("Datasets:", paste(datasets, collapse = ", "), "\n\n")

  # Create static plot map with all geometries in one layer (tmap v4 syntax)
  tmap_mode("plot")

  map <- tm_shape(pa_subset) +
    tm_polygons(
      fill = "dataset_id",
      fill_alpha = 0.5,
      col = "black",
      lwd = 1,
      fill.scale = tm_scale(values = "brewer.set2"),
      fill.legend = tm_legend(
        title = "Data Source",
        position = tm_pos_out("right")
      )
    ) +
    tm_title(wdpa_name)

  return(map)
}

add_modif_cnlegis <- function(
  sat,
  data,
  decisions,
  wdpa_name_or_id,
  decision_filter,
  source_dataset_id,
  amendment_type = "boundary_modification",
  valid_from = NULL,
  confidence = "medium",
  verification_method = "visual_verification_shiny",
  verified_by = "project_team",
  notes = NULL
) {
  # English: accept WDPAID (numeric) or WDPA_NAME (character) and return a single WDPAID
  resolve_wdpaid <- function(wdpa_name_or_id, decisions) {
    if (is.numeric(wdpa_name_or_id)) {
      return(wdpa_name_or_id[1])
    }
    wdpaid <- decisions %>%
      filter(WDPA_NAME == wdpa_name_or_id) %>%
      pull(WDPAID) %>%
      first()
    if (is.na(wdpaid)) {
      stop("WDPAID introuvable pour: ", wdpa_name_or_id)
    }
    wdpaid
  }

  if (!is.list(decision_filter)) {
    stop("decision_filter doit être une liste.")
  }

  wdpaid <- resolve_wdpaid(wdpa_name_or_id, decisions)

  # Select exactly one CNLEGIS decision
  dec <- decisions %>%
    filter(WDPAID == wdpaid)

  if (!is.null(decision_filter$year)) {
    dec <- dec %>% filter(lubridate::year(date_texte) == decision_filter$year)
  }
  if (!is.null(decision_filter$type_decision_pattern)) {
    dec <- dec %>%
      filter(str_detect(type_decision, decision_filter$type_decision_pattern))
  }
  if (!is.null(decision_filter$num_texte)) {
    dec <- dec %>% filter(num_texte == decision_filter$num_texte)
  }
  if (!is.null(decision_filter$id_texte)) {
    dec <- dec %>% filter(id_texte == decision_filter$id_texte)
  }

  dec <- dec %>% arrange(date_texte)

  if (nrow(dec) == 0) {
    stop("Aucune décision CNLEGIS ne correspond au filtre pour WDPAID=", wdpaid)
  }
  if (nrow(dec) > 1) {
    stop(
      "Filtre CNLEGIS ambigu: plusieurs décisions correspondent. Raffiner decision_filter."
    )
  }

  # Extract "before" geometry from all_PAs_conso
  geom_before <- data %>%
    filter(WDPAID == wdpaid, dataset_id == source_dataset_id) %>%
    filter(dataset_id != "CNLEGIS_2024") %>%
    st_zm(drop = TRUE, what = "ZM") %>%
    st_make_valid()

  if (nrow(geom_before) == 0) {
    stop(
      "Aucune géométrie trouvée pour source_dataset_id=",
      source_dataset_id,
      " et WDPAID=",
      wdpaid
    )
  }

  # Build SAT entry
  sat_entry <- geom_before %>%
    mutate(
      WDPAID = wdpaid,
      amendment_type = amendment_type,
      valid_from = if (!is.null(valid_from)) {
        as.Date(valid_from)
      } else {
        as.Date(NA)
      },
      valid_to = dec$date_texte[1],
      date_precision = "day",
      data_source = source_dataset_id,
      legal_source = dec$num_texte[1],
      cnlegis_url = if ("cnlegis_url" %in% names(dec)) {
        dec$cnlegis_url[1]
      } else {
        NA_character_
      },
      verification_method = verification_method,
      verified_by = verified_by,
      verification_date = Sys.Date(),
      notes = ifelse(is.null(notes), dec$objet_texte[1], notes),
      confidence = confidence
    ) %>%
    select(
      WDPAID,
      geometry,
      amendment_type,
      valid_from,
      valid_to,
      date_precision,
      data_source,
      legal_source,
      cnlegis_url,
      verification_method,
      verified_by,
      verification_date,
      notes,
      confidence
    )

  # Initialize sat if needed
  if (is.null(sat)) {
    sat_new <- sat_entry
  } else {
    sat_new <- bind_rows(sat, sat_entry)
  }

  # Assign stable amendment_id (sequential)
  sat_new <- sat_new %>%
    mutate(amendment_id = row_number()) %>%
    relocate(amendment_id, .before = WDPAID)

  # Duplicate guard on key tuple
  dups <- sat_new %>%
    st_drop_geometry() %>%
    count(WDPAID, valid_to, data_source, legal_source) %>%
    filter(n > 1)

  # if (nrow(dups) > 0) {
  #   stop("Doublon SAT détecté (WDPAID, valid_to, data_source, legal_source).")
  # }

  sat_new
}

```

#### Ambatovaky

Goodman et al. [-@goodman2018] indique pour cette AP:

> Aspects	légaux	:	Gestionnaire	actuel	:	Madagascar	National	Parks	(MNP)	;
Gestion	antérieure	:	aucune	;	Création	:	selon	le	Décret	n°	58-10	du	28
octobre	1958	(Création	de	la	Réserve	Spéciale)	;	Modification	de	statut	:
Ambatovaky	fut	institué	en	réserve	spéciale	en	1958	selon	le	Décret	n°	58-10
du	28	octobre	1958.	Les	limites	de	l’aire	protégée	ne	furent	précisées	qu’en
1965	avec	l’Arrêté	n°	1036/MFR/FOR	du	1	avril	1965	(60	050	ha)	puis
modifiées	en	2015	suivant	le	Décret	n°	2015-731	du	21	avril	2015	;	Dernière
modification	de	statut	:	suivant	le	Décret	n°	2015-731	du	21	avril	2015	;
Surface	actuelle	:	78	139	ha	(selon	le	décret	en	vigueur).


L'attibut STATUS_YR d'Ambatovaky indiquent qu'elle a été créée en 1958, mais au moins une décision a modifié son statut depuis : 

```{r}
show_cnlegis_for_pa("Ambatovaky", pa_decisions, pattern = "modifiant") %>%
  select(
    date_texte,
    type_texte,
    num_texte,
    type_decision,
    id_texte,
    objet_texte
  )
```

Le périmètre correspondant à l'étendue de l'AP avant 2015 est celui fourni par de MNP.

```{r}
plot_pa_sources(
  "Ambatovaky",
  sources = c("WDPA_2025", "MNP_2010")
)
```

On retient comme géométrie avant 2015 la meilleure source spatiale identifiée dans `all_PAs_conso` (ici `MNP_2010`), en attendant la vérification du périmètre alternatif (ANGAP 2002 / WDPA archives).

```{r}
sat <- NULL |>
  add_modif_cnlegis(
    data = all_PAs_conso,
    decisions = pa_decisions,
    wdpa_name_or_id = "Ambatovaky",
    decision_filter = list(year = 2015, type_decision_pattern = "modifiant"),
    source_dataset_id = "MNP_2010",
    notes = "Périmètre antérieur au décret modifiant (géométrie MNP_2010 retenue après vérification visuelle)."
  )

```


#### Analamazaotra 


Goodman et al. [-@goodman2018] indique pour cette AP:

> Aspects	légaux	:	Gestionnaire	actuel	:	Madagascar	National	Parks	(MNP)	; 
Gestion	antérieure	:	Direction	des	Eaux	et	Forêts	(Service	de	la	Protection
de	la	Nature	d’Antananarivo	et	le	Cantonnement	Forestier	de
Moramanga)	;	Création	:	selon	le	Arrêté	n°	2778/MAER/SEGREF/FOR	du
21	juillet	1970	;	Modification	de	statut	:	l’ancienne	Station	Forestière
d’Analamazaotra,	composée	de	deux	parcelles,	ainsi	que	la	Réserve	de
faune	pour	Indris	existant	depuis	1970	(Arrêté	n°
2778/MAER/SEGREF/FOR)	constituent	le	parc	national	créé	en	2015,	selon
le	Décret	n°	2015-732	du	21	avril	2015	;	Dernière	modification	de	statut	:
suivant	le	Décret	n°	2015-732	du	21	avril	2015	;	Surface	actuelle	:	874	ha
(selon	le	décret	en	vigueur).

Les métadonnées indiquent que cette aire protégée a été créée en 1970 (Arrêté 2778/70), puis modifiée en 2015 :

```{r}
show_cnlegis_for_pa(5021, pa_decisions) %>%
  select(
    date_texte,
    type_texte,
    num_texte,
    type_decision,
    id_texte,
    objet_texte
  )
```

Après inspection visuelle des différentes sources disponibles, on retient SAPM 2010 comme source des limites avant la modification de 2015.

```{r}
plot_pa_sources(
  "Analamazaotra",
  sources = c("WDPA_2025", "SAPM_2010")
)
```

Conformément aux règles de construction de la SAT, seule la géométrie immédiatement antérieure à la modification de 2015 est ajoutée comme amendement spatial.

```{r}
sat <- sat |>
  add_modif_cnlegis(
    data = all_PAs_conso,
    decisions = pa_decisions,
    wdpa_name_or_id = "Analamazaotra",
    decision_filter = list(year = 2015, type_decision_pattern = "modifiant"),
    source_dataset_id = "SAPM_2010",
    valid_from = "1970-07-21",
    notes = "Périmètre antérieur au décret modifiant (géométrie SAPM_2010 retenue après vérification visuelle)."
  )
```

::: {.callout-note}
L'année de création de cette AP est 1970 (pas 2015 comme indiqué dans la WDPA 2025). A refléter dans FAT, ou s'assurer que CAR accorde la primauté à valid_from dans SAT si disponible.
:::

#### Andohahela 

Goodman et al. [-@goodman2018] indique pour cette AP:
> Aspects	légaux	:	Gestionnaire	actuel	:	Madagascar	National	Parks	(MNP)	;
Gestion	antérieure	:	Direction	des	Eaux	et	Forêts	(Service	de	la	Protection
de	la	Nature	d’Antananarivo	et	le	Cantonnement	Forestier	de	Tolagnaro)	;
Création	:	selon	le	Décret	du	11	juin	1939	(Création	de	la	Réserve	Naturelle
Intégrale	n°	11)	;	Modification	de	statut	:	la	Réserve	Naturelle	Intégrale
d’Andohahela	fut	créée	en	1939	suivant	le	Décret	du	11	juin	1939	et	ses
limites	ont	été	définies	en	1966	avec	Décret	n°	66-242	du	1	juin	1966.	Cette
aire	protégée	a	la	particularité	d’être	constituée	de	trois	parcelles
adjacentes.	En	2002,	elle	subit	un	déclassement	en	parc	national	selon	le
Décret	n°	97-1043	du	7	août	2002.	Le	Décret	n°	2015-785	du	28	avril	2015
apporte	un	léger	changement	de	limites	aux	trois	parcelles	qui	composaient
déjà	l’aire	protégée	(Parcelle	I	:	62	124	ha	;	Parcelle	II	:	13	759	ha	;	Parcelle
III	:	437	ha)	;	Dernière	modification	de	statut	:	suivant	le	Décret	n°	2015-
785	du	28	avril	2015	;	Surface	actuelle	:	76	140	ha	(selon	le	décret	en
vigueur).

NB : Il y a visiblement une erreur dans le texte, le décret 97-1043 date de 1997, pas 2002.

Les sources secondaires indiquent qu’Andohahela a connu plusieurs évolutions juridiques et spatiales depuis sa création initiale. Créée en 1939 comme Réserve Naturelle Intégrale, l’aire protégée a vu ses limites précisées en 1966, puis son statut modifié en 2002 lors de son déclassement en Parc National. Ces événements sont antérieurs à la disponibilité de données spatiales numériques homogènes et ne peuvent donc pas être documentés directement dans la Spatial Amendment Table.

Les textes réglementaires récents identifiés dans CNLEGIS confirment en revanche une modification explicite des limites en 2015, par l’Arrêté n°2015-785 du 28 avril 2015, portant modification des limites du Parc National d’Andohahela. On la retrouve bien dans nos données CNLEGIS :

```{r}
show_cnlegis_for_pa("Andohahela", pa_decisions) %>%
  select(
    date_texte,
    type_texte,
    num_texte,
    type_decision,
    id_texte,
    objet_texte
  )
```

Cette décision juridique constitue un déclencheur clair pour l’introduction d’un amendement spatial dans la SAT.
On trouve plusieurs périmètres distincts dans les données. D'après les cartes disponible dans le plan d'aménagement et de gestion d'Andohahela datant de 2012, les polygones inclus dans SAPM 2010 sont ceux qui correspondent aux délimitations utilisées avant 2015. 

```{r}
plot_pa_sources(
  "Andohahela",
  sources = c("WDPA_2025", "SAPM_evol_2001-2011")
)
```

Conformément aux règles de construction de la SAT, seule la géométrie immédiatement antérieure à la modification de 2015 est retenue comme amendement spatial documenté.

```{r}
sat <- sat |>
  add_modif_cnlegis(
    data = all_PAs_conso,
    decisions = pa_decisions,
    wdpa_name_or_id = "Andohahela",
    decision_filter = list(year = 2015, type_decision_pattern = "modifiant"),
    source_dataset_id = "SAPM_evol_2001-2011",
    notes = "Périmètre antérieur au décret modifiant (géométrie SAPM_2010 retenue après vérification visuelle)."
  )
```

#### Andringitra

Vérification de la nature des modifications pour Andringitra

```{r}
andringitra_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 2308) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(andringitra_decision_2015, -objet_texte),
  andringitra_decision_2015$objet_texte
))
```

La modification survenue en 1998 ne porte pas sur un changement de frontière. Elle porte sur un chanement de statut juridique, de RNI à PN. 

::: {.callout-note}
La modification introduite en 1998 transforme la RNI en PN. Si cela a une implication substantielle (cf. [issue #8](https://github.com/BETSAKA/conservation-dynamic-madagascar/issues/8)) alors il faudra l'inclure dans FAT.
:::

#### Anjanaharibe_sud

```{r}
anjanaharibe_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 5023) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(anjanaharibe_decision_2015, -objet_texte),
  anjanaharibe_decision_2015$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Anjanaharibe_sud")
```

- WDPA 2025 = WPDA 2024 = WDPA 2017 = Vahatra
- WDPA 2010:2019 = ANGAP 2002
- WDPA 2024 semble très faux.
- SAPM 2010 = SAPM 2001-2011 très différent

```{r}
plot_pa_by_name(
  "Anjanaharibe_sud",
  sources = c("WDPA_2025", "ANGAP_2002")
)
```

> Ajouter ANGAP 2002

## Ankarafantsika

```{r}
ankarafantsika_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 1299) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(ankarafantsika_decision_2015, -objet_texte),
  ankarafantsika_decision_2015$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Ankarafantsika")
```

- ANGAP 2002 = SAPM 2010:2019
- WDPA 2025 = SAPM 2010, 2017, 2024
- WDPA 2024 inclut la zone de protection

```{r}
plot_pa_by_name(
  "Ankarafantsika",
  sources = c("WDPA_2025", "ANGAP_2002")
)
```

> Ajout de ANGAP 2002

The extension of the protected area in 2002 was mapped as follows in 2002 by experts from the NGO Conservation International, which spearheaded the initiative.

![Ankarafantsika 2002 expansion](data/Alonso_Shuldenberg_2002.png)

```{r}
wdpa_hist <- read_parquet("data/MDG_WDPA_Consolidated.parquet") %>%
  mutate(geometry = st_as_sfc(geometry)) %>%
  st_as_sf() %>%
  mutate(dataset_id = paste0("WDPA_", data_year)) |>
  st_transform(st_crs(all_PAs_conso))


ankarafantsika_2002_2015 <- NULL |>
  add_modif_cnlegis(
    data = wdpa_hist,
    decisions = pa_decisions,
    wdpa_name_or_id = "Ankarafantsika",
    decision_filter = list(year = 2015, type_decision_pattern = "modifiant"),
    source_dataset_id = "WDPA_2010",
    notes = "Possible problème de projection, cf. comparaison avec ANGAP"
  ) |>
  add_modif_cnlegis(
    data = all_PAs_conso,
    decisions = pa_decisions,
    wdpa_name_or_id = "Ankarafantsika",
    decision_filter = list(year = 2015, type_decision_pattern = "modifiant"),
    source_dataset_id = "ANGAP_2002",
    notes = "Possible problème de projection, cf. comparaison avec WDPA"
  )

st_write(ankarafantsika_2002_2015, "ankarafantsika_2002_2015.geojson")
```

## Bemaraha 

```{r}
bemaraha_decision <- pa_decisions %>%
  filter(WDPAID == 303702) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(bemaraha_decision, -objet_texte),
  bemaraha_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name(303702)
```

- ANGAP 2002 (périmètre Sud) = WDPA 2010:2019
- ANGAP 2002 (périmètre Nord) 
- ANGAP 2002 (très petit périmètre centre) dans aucun autre


> Ajouter SAPM 2010 ou version MNP


```{r}
plot_pa_by_name(
  303702,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Beza Mahafaly

```{r}
beza_decision <- pa_decisions %>%
  filter(WDPAID == 10634) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(beza_decision, -objet_texte),
  beza_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Beza Mahafaly")
```

```{r}
plot_pa_by_name(
  10634,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Cap Sainte Marie

```{r}
cap_decision <- pa_decisions %>%
  filter(WDPAID == 5041) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(cap_decision, -objet_texte),
  cap_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Cap Sainte Marie")
```

```{r}
plot_pa_by_name(
  5041,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Kirindy Mite

```{r}
kirindy_decision <- pa_decisions %>%
  filter(WDPAID == 303700) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(kirindy_decision, -objet_texte),
  kirindy_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Kirindy Mite")
```

```{r}
plot_pa_by_name(
  303700,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Mangerivola

```{r}
mangerivola_decision <- pa_decisions %>%
  filter(WDPAID == 5038) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(mangerivola_decision, -objet_texte),
  mangerivola_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Mangerivola")
```

```{r}
plot_pa_by_name(
  5038,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Manombo

```{r}
manombo_decision <- pa_decisions %>%
  filter(WDPAID == 5028) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(manombo_decision, -objet_texte),
  manombo_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Manombo")
```

```{r}
plot_pa_by_name(
  5028,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Manongarivo

```{r}
manongarivo_decision <- pa_decisions %>%
  filter(WDPAID == 5026) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(manongarivo_decision, -objet_texte),
  manongarivo_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Manongarivo")
```

```{r}
plot_pa_by_name(
  5026,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Mantadia

```{r}
mantadia_decision <- pa_decisions %>%
  filter(WDPAID == 26070) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(mantadia_decision, -objet_texte),
  mantadia_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Mantadia")
```

```{r}
plot_pa_by_name(
  26070,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Marojejy

```{r}
marojejy_decision <- pa_decisions %>%
  filter(WDPAID == 2305) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(marojejy_decision, -objet_texte),
  marojejy_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Marojejy")
```

```{r}
plot_pa_by_name(
  2305,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Montagne d'Ambre

```{r}
montagne_decision <- pa_decisions %>%
  filter(WDPAID == 2314) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(montagne_decision, -objet_texte),
  montagne_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Montagne d'Ambre")
```

```{r}
plot_pa_by_name(
  2314,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Namoroka

```{r}
namoroka_decision <- pa_decisions %>%
  filter(WDPAID == 2309) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(namoroka_decision, -objet_texte),
  namoroka_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Namoroka")
```

```{r}
plot_pa_by_name(
  2309,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Nosy Mangabe

```{r}
nosy_decision <- pa_decisions %>%
  filter(WDPAID == 5039) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(nosy_decision, -objet_texte),
  nosy_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Nosy Mangabe")
```

```{r}
plot_pa_by_name(
  5039,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Tsimanampesotse

```{r}
tsimanampesotse_decision <- pa_decisions %>%
  filter(WDPAID == 2307) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(tsimanampesotse_decision, -objet_texte),
  tsimanampesotse_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Tsimanampesotse")
```

```{r}
plot_pa_by_name(
  2307,
  sources = c("WDPA_2025") # Update after visual inspection
)
```

## Zahamena

```{r}
zahamena_decision <- pa_decisions %>%
  filter(WDPAID == 354013) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(zahamena_decision, -objet_texte),
  zahamena_decision$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Zahamena")
```


```{r}
plot_pa_by_name(
  354013,
  sources = c("WDPA_2025") # Update after visual inspection
)
```