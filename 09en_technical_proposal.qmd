# Technical proposal (English)

The dataset is designed as a time explicit extension of WDPA polygon data that incorporates legal history, spatial changes, and internal zoning of protected areas when such information is available. WDPA provides the default current state of each protected area, but this state is treated as a single segment within a longer trajectory marked by changes in legal status, boundaries, and internal organization. For each WDPAID, the dataset reconstructs successive states of the protected area, each defined by explicit validity periods, by mobilizing dated legal and spatial information when available, while remaining fully compatible with WDPA when such information is absent.

The core principle relies on default completion combined with explicit and deterministic precedence rules. In the absence of alternative information, WDPA attributes and geometry define a single state whose validity period starts from STATUS_YR, interpreted using a documented date convention, and extends to the reference date of the WDPA release. When earlier legal decisions, previous boundaries, or internal zoning arrangements are identified through supplementary sources, the timeline is split into multiple non overlapping validity intervals. Earlier states inherit WDPA attributes by default, except where legal texts, dated perimeters, or zoning documents explicitly indicate differences, such as temporary protection status, alternative boundaries, changes in management, or a specific internal organization.

Legal history, boundary evolution, and the establishment of internal zoning are treated as independent sources of temporal segmentation. Dates derived from legal texts, zoning instruments, or boundary modifications jointly structure the timeline. Each resulting interval is then populated with the most specific information available for the period considered, both at the protected area level and, when relevant, for its internal zones. External boundaries are treated as a specific zone type, allowing internal zoning and outer limits to follow a unified spatial logic.

Concretely, the dataset does not replace WDPA. It is constructed from four complementary components, each with a clearly defined role:

- **WDPA**
The global WDPA polygon dataset, used as the baseline reference describing the current state of protected areas.

- **SAT - Spatial Amendment Table**
A table of spatial amendments containing dated historical boundaries and internal zoning geometries that differ from the current WDPA representation.

- **FAT — Feature Amendment Table**
A table of attribute amendments containing dated legal and administrative modifications, such as changes in protection status, management delegation, designation, or governance arrangements.

• **CAR - Consolidation and Auditing Rules**
A stable and transparent set of consolidation rules, expressed as human readable and reproducible code, that specify how WDPA, SAT, and FAT are combined, how temporal segmentation is performed, and how precedence between sources is resolved and made auditable.

Together, these components generate a derived dynamic state table in which each WDPA protected area is represented by a sequence of time bounded states. WDPA provides the default current state, while SAT and FAT only intervene when explicit dated information is available, triggering a segmentation of the timeline and, when relevant, a modification of geometry, legal status, or internal zoning as specified by CAR. In the absence of such information, WDPA data are simply extended backward or forward unchanged according to documented conventions.

The resulting dataset remains fully compatible with WDPA identifiers and structure, while making temporal assumptions explicit, reproducible, and testable. The contribution therefore lies both in the publication of curated supplementary data on legal and spatial histories (SAT and FAT), and in the transparent consolidation and auditing procedures (CAR) that allow WDPA to be transformed into a time explicit conservation dataset suitable for longitudinal and impact analyses.

## Composition of SAT


```{r}
library(tidyverse)
library(sf)
library(tmap)
library(arrow)
library(geoarrow)

# Load the consolidated data
all_PAs_conso <- read_rds("data/id/all_PAs_conso.rds")

# Identify PAs with same WDPAID but different geometries/overlaps
border_discrepancies <- all_PAs_conso %>%
  # Filter to records that have both a WDPAID and overlap info
  filter(!is.na(WDPAID), !is.na(overlap_WDPA)) %>%
  # Exclude the WDPA source itself to avoid self-comparison
  filter(dataset_id != "WDPA_2025") %>%
  # Group by WDPAID to find multiple representations
  group_by(WDPAID) %>%
  mutate(
    n_representations = n(),
    min_overlap = min(overlap_WDPA, na.rm = TRUE),
    max_overlap = max(overlap_WDPA, na.rm = TRUE),
    overlap_range = max_overlap - min_overlap,
    mean_overlap = mean(overlap_WDPA, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # Flag significant discrepancies
  mutate(
    has_discrepancy = case_when(
      n_representations == 1 ~ "Single source",
      overlap_range > 0.3 ~ "High discrepancy (>30%)",
      overlap_range > 0.15 ~ "Moderate discrepancy (15-30%)",
      max_overlap < 0.7 ~ "Low overall overlap",
      TRUE ~ "Good consistency"
    )
  ) %>%
  # Focus on problematic cases
  filter(
    has_discrepancy %in%
      c(
        "High discrepancy (>30%)",
        "Moderate discrepancy (15-30%)",
        "Low overall overlap"
      )
  )

# Summary by PA
discrepancy_summary <- border_discrepancies %>%
  st_drop_geometry() %>%
  select(
    WDPAID,
    WDPA_NAME,
    NAME,
    dataset_id,
    overlap_WDPA,
    n_representations,
    overlap_range,
    has_discrepancy
  ) %>%
  arrange(desc(overlap_range), WDPAID)

# View PA names with substantial discrepancies
diff_WDPA_name <- unique(discrepancy_summary$WDPA_NAME)
diff_WDPA_id <- unique(discrepancy_summary$WDPAID)
```

So we have `r length(diff_WDPA_name)` PAs with spatial discrepancies > 15%.

```{r}
print(diff_WDPA_name)
```

Now see in ou legal modifications which ones we have corresponding decrees

```{r}
pa_decisions <- read_rds("data/id/legal_texts.rds")

modification_decisions <- pa_decisions |>
  filter(str_detect("modifiant", type_decision))

modification_decision_names <- unique(modification_decisions$WDPA_NAME) |>
  sort()
modification_decision_names
```

We have `r length(modification_decision_names)` border modification decisions registered.

```{r}
# 2 functions: 1 for exploratory data analysis, the other to display identified
# datasets

# Function to visualize all representations of a PA by WDPA name
# Looks up the WDPAID from pa_decisions, then filters all_PAs_conso by that ID
# Each row becomes a separately controllable layer
visualize_pa_by_name <- function(
  wdpa_name,
  data = all_PAs_conso,
  decisions = pa_decisions,
  wdpa_historical_path = "data/MDG_WDPA_Consolidated.parquet",
  sources = NULL
) {
  # Check if input is a WDPAID (integer) or name (string)
  if (is.numeric(wdpa_name)) {
    wdpaid <- wdpa_name
  } else {
    # Look up the WDPAID from pa_decisions
    wdpaid <- decisions %>%
      filter(WDPA_NAME == wdpa_name) %>%
      pull(WDPAID) %>%
      first()

    # Check if WDPAID was found
    if (is.na(wdpaid)) {
      message("No WDPAID found in pa_decisions for: ", wdpa_name)
      return(NULL)
    }
  }

  # Filter all observations matching this WDPAID from all_PAs_conso
  pa_subset <- data %>%
    filter(WDPAID == wdpaid) %>%
    mutate(layer_id = paste0(dataset_id, " - ", row_number()))

  # Load and filter WDPA historical data
  wdpa_historical <- read_parquet(wdpa_historical_path) %>%
    mutate(geometry = st_as_sfc(geometry)) %>%
    st_as_sf() %>%
    filter(WDPAID == wdpaid) %>%
    mutate(dataset_id = paste0("WDPA_", data_year)) %>%
    st_transform(st_crs(pa_subset))

  # Combine both datasets
  pa_subset <- bind_rows(pa_subset, wdpa_historical)

  # Filter by specified sources if provided
  if (!is.null(sources) && length(sources) > 0) {
    pa_subset <- pa_subset %>%
      filter(dataset_id %in% sources) %>%
      # Convert to factor with levels in the order specified by sources
      mutate(dataset_id = factor(dataset_id, levels = sources))
  }

  # Check if any results found
  if (nrow(pa_subset) == 0) {
    message("No protected area found with WDPAID: ", wdpaid)
    return(NULL)
  }

  # Get summary information
  n_obs <- nrow(pa_subset)
  datasets <- unique(pa_subset$dataset_id)

  # Print summary
  cat("\n=== ", wdpa_name, " ===\n")
  cat("WDPAID:", wdpaid, "\n")
  cat("Number of representations:", n_obs, "\n")
  cat("Datasets:", paste(datasets, collapse = ", "), "\n\n")

  # Create static plot map with all geometries in one layer (tmap v4 syntax)
  tmap_mode("view")

  map <- NULL

  # Add each row as a separate shape layer
  for (i in seq_len(nrow(pa_subset))) {
    row_data <- pa_subset[i, ]
    layer_name <- paste0(row_data$dataset_id, " (", i, ")")

    if (is.null(map)) {
      map <- tm_shape(row_data, name = layer_name) +
        tm_polygons(
          col = "dataset_id",
          alpha = 0.4,
          id = "layer_id",
          popup.vars = c(
            "NAME",
            "WDPA_NAME",
            "dataset_id",
            "overlap_WDPA",
            "STATUS_YR",
            "DESIG",
            "IUCN_CAT",
            "date_texte",
            "type_texte",
            "num_texte"
          ),
          palette = "Set3",
          title = "Data Source",
          group = layer_name
        )
    } else {
      map <- map +
        tm_shape(row_data, name = layer_name) +
        tm_polygons(
          col = "dataset_id",
          alpha = 0.4,
          id = "layer_id",
          popup.vars = c(
            "NAME",
            "WDPA_NAME",
            "dataset_id",
            "overlap_WDPA",
            "STATUS_YR",
            "DESIG",
            "IUCN_CAT",
            "date_texte",
            "type_texte",
            "num_texte"
          ),
          palette = "Set3",
          title = "Data Source",
          group = layer_name
        )
    }
  }

  map <- map +
    tm_layout(
      title = paste(wdpa_name, "- All representations"),
      frame = FALSE
    )

  return(map)
}

plot_pa_by_name <- function(
  wdpa_name,
  data = all_PAs_conso,
  decisions = pa_decisions,
  wdpa_historical_path = "data/MDG_WDPA_Consolidated.parquet",
  sources = NULL
) {
  # Check if input is a WDPAID (integer) or name (string)
  if (is.numeric(wdpa_name)) {
    wdpaid <- wdpa_name
  } else {
    # Look up the WDPAID from pa_decisions
    wdpaid <- decisions %>%
      filter(WDPA_NAME == wdpa_name) %>%
      pull(WDPAID) %>%
      first()

    # Check if WDPAID was found
    if (is.na(wdpaid)) {
      message("No WDPAID found in pa_decisions for: ", wdpa_name)
      return(NULL)
    }
  }

  # Filter all observations matching this WDPAID from all_PAs_conso
  pa_subset <- data %>%
    filter(WDPAID == wdpaid)

  # Load and filter WDPA historical data
  wdpa_historical <- read_parquet(wdpa_historical_path) %>%
    mutate(geometry = st_as_sfc(geometry)) %>%
    st_as_sf() %>%
    filter(WDPAID == wdpaid) %>%
    mutate(dataset_id = paste0("WDPA_", data_year)) %>%
    st_transform(st_crs(pa_subset))

  # Combine both datasets
  pa_subset <- bind_rows(pa_subset, wdpa_historical)

  # Filter by specified sources if provided
  if (!is.null(sources) && length(sources) > 0) {
    pa_subset <- pa_subset %>%
      filter(dataset_id %in% sources) %>%
      # Convert to factor with levels in the order specified by sources
      mutate(dataset_id = factor(dataset_id, levels = sources))
  }

  # Check if any results found
  if (nrow(pa_subset) == 0) {
    message("No protected area found with WDPAID: ", wdpaid)
    return(NULL)
  }

  # Get summary information
  n_obs <- nrow(pa_subset)
  datasets <- unique(pa_subset$dataset_id)

  # Print summary
  cat("\n=== ", wdpa_name, " ===\n")
  cat("WDPAID:", wdpaid, "\n")
  cat("Number of representations:", n_obs, "\n")
  cat("Datasets:", paste(datasets, collapse = ", "), "\n\n")

  # Create static plot map with all geometries in one layer (tmap v4 syntax)
  tmap_mode("plot")

  map <- tm_shape(pa_subset) +
    tm_polygons(
      fill = "dataset_id",
      fill_alpha = 0.5,
      col = "black",
      lwd = 1,
      fill.scale = tm_scale(values = "brewer.set2"),
      fill.legend = tm_legend(
        title = "Data Source",
        position = tm_pos_out("right")
      )
    ) +
    tm_title(wdpa_name)

  return(map)
}
```

## Ambatovaky

```{r}
ambatovaky_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 5037, year(date_texte) == 2015) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(ambatovaky_decision_2015, -objet_texte),
  ambatovaky_decision_2015$objet_texte
))
```


```{r}
#| echo: false
#| eval: false
visualize_pa_by_name(
  "Ambatovaky",
  sources = c("WDPA_2025", "WDPA_2024", "ANGAP_2002")
)
```


```{r}
plot_pa_by_name(
  "Ambatovaky",
  sources = c("ANGAP_2002", "WDPA_2025", "WDPA_2024")
)
```

3 different perimeters: 
- WDPA 2025
- WDPA 2024 : much larger than WDPA 2025 (includes protection zone?)
- WDPA < 2020 | ANGAP 2002: smaller than WPDA 2025

> To be added to SAT: ANGAP_2002

## Analamazaotra 

```{r}
analamazotra_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 5021) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(analamazotra_decision_2015, -objet_texte),
  analamazotra_decision_2015$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Analamazaotra")
```

```{r}
plot_pa_by_name(
  "Analamazaotra",
  sources = c("WDPA_2025", "SAPM_2010", "WDPA_2024")
)
```

different peremetrs
- WDPA 2025
- WDPA 2020:2024: larger (includes protection zone?)
- SAPM 2010 (and others) smaller and clearer borders

> To be added to SAT: SAPM 2010

## Andohahela 

```{r}
andohahela_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 2303) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(andohahela_decision_2015, -objet_texte),
  andohahela_decision_2015$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Andohahela")
```

Three different versions
- WDPA 2025 = SAPM 2024 = SAPM 2017
- WDPA 2024 = 
- ANGAP 2002 = WDPA <= 2016

```{r}
plot_pa_by_name(
  "Andohahela",
  sources = c("WDPA_2025", "ANGAP_2002", "WDPA_2024")
)
```


## Andringitra

```{r}
andringitra_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 2308) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(andringitra_decision_2015, -objet_texte),
  andringitra_decision_2015$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Andringitra")
```

- WDPA 2025 = SAPM 2017 = SAPM 2025 = Vahatra
- WDPA 2020:2024 = trop large (inclut la zone de protection probablement)
- WDPA 2010:2019: frontières plus simples qu'on ne retrouve avec des différences modérées avec la plupart des autres sources
- ANGAP 2002 = SAPM 2010 = SAPM evol 2001-2011 (avec year = 2002)

```{r}
plot_pa_by_name(
  "Andringitra",
  sources = c("WDPA_2025", "ANGAP_2002")
)
```

> Garder ANGAP_2002

## Anjanaharibe_sud

```{r}
anjanaharibe_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 5023) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(anjanaharibe_decision_2015, -objet_texte),
  anjanaharibe_decision_2015$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Anjanaharibe_sud")
```

- WDPA 2025 = WPDA 2024 = WDPA 2017 = Vahatra
- WDPA 2010:2019 = ANGAP 2002
- WDPA 2024 semble très faux.
- SAPM 2010 = SAPM 2001-2011 très différent

```{r}
plot_pa_by_name(
  "Anjanaharibe_sud",
  sources = c("WDPA_2025", "ANGAP_2002")
)
```

> Ajouter ANGAP 2002

## Ankarafantsika

```{r}
ankarafantsika_decision_2015 <- pa_decisions %>%
  filter(WDPAID == 1299) %>%
  select(date_texte, type_texte, type_decision, id_texte, objet_texte)
print(list(
  select(ankarafantsika_decision_2015, -objet_texte),
  ankarafantsika_decision_2015$objet_texte
))
```

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Ankarafantsika")
```

- ANGAP 2002 = SAPM 2010:2019
- WDPA 2025 = SAPM 2010, 2017, 2024
- WDPA 2024 inclut la zone de protection

```{r}
plot_pa_by_name(
  "Ankarafantsika",
  sources = c("WDPA_2025", "ANGAP_2002")
)
```

> Ajout de ANGAP 2002

The extension of the protected area in 2002 was mapped as follows in 2002 by experts from the NGO Conservation International, which spearheaded the initiative.

![Ankarafantsika 2002 expansion](data/Alonso_Shuldenberg_2002.png)

## Bemaraha 

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name(303702)
```

## Beza Mahafaly

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Beza Mahafaly")
```

## Cap Sainte Marie

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Cap Sainte Marie")
```

## Kirindy Mite

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Kirindy Mite")
```

## Mangerivola

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Mangerivola")
```

## Manombo

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Manombo")
```

## Manongarivo

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Manongarivo")
```

## Mantadia

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Mantadia")
```

## Marojejy

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Marojejy")
```

## Montagne d'Ambre

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Montagne d'Ambre")
```

## Namoroka

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Namoroka")
```

## Nosy Mangabe

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Nosy Mangabe")
```

## Tsimanampesotse

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Tsimanampesotse")
```

## Zahamena

```{r}
#| echo: false
#| eval: false
visualize_pa_by_name("Zahamena")
```